// Mineflayer bot script with pathfinding, block collection, and PVP (see documentation/examples01)
const mineflayer = require('mineflayer');
const pathfinder = require('mineflayer-pathfinder').pathfinder;
const { Movements, goals: { GoalNear, GoalBlock } } = require('mineflayer-pathfinder');
const collectBlock = require('mineflayer-collectblock').plugin;
const pvp = require('mineflayer-pvp').plugin;
const tool = require('mineflayer-tool').plugin;
const minecraftData = require('minecraft-data');
const { Vec3 } = require('vec3');

// Create bot (offline auth for cracked server support)
const bot = mineflayer.createBot({
  host: 'TESTWorld182.aternos.me',
  port: 53373,
  username: 'bot',
  version: '1.21.5',
  auth: 'offline'
});

// Load plugins: pathfinder for navigation, collectblock for mining, pvp for combat, tool for tool selection
bot.loadPlugin(pathfinder);    // pathfinder plugin2
bot.loadPlugin(collectBlock);  // collectBlock plugin for block collection3
bot.loadPlugin(pvp);           // PVP plugin for attacking
bot.loadPlugin(tool);          // Tool plugin for auto-equipping best tool

bot.once('spawn', () => {
  const mcData = minecraftData(bot.version);
  // Configure pathfinding movements and avoidance4
  const defaultMove = new Movements(bot, mcData);
  defaultMove.allow1by1towers = false;  // disable 1x1 tower building
  defaultMove.canDig = false;           // disable digging while pathing
  // Avoid lava and flowing lava for safety (dangerous terrain)
  defaultMove.blocksToAvoid.add(mcData.blocksByName.lava.id);
  defaultMove.blocksToAvoid.add(mcData.blocksByName.flowing_lava.id);
  // Avoid creeper entities (by registry name "minecraft:creeper")
  defaultMove.entitiesToAvoid.add('minecraft:creeper');
  bot.pathfinder.setMovements(defaultMove);

  bot.chat('Bot is ready!');
});

// Helper: mine nearest block of given type
async function mineBlockType(blockName) {
  const mcData = minecraftData(bot.version);
  const blockId = mcData.blocksByName[blockName] && mcData.blocksByName[blockName].id;
  if (!blockId) {
    bot.chat(`Unknown block type: ${blockName}`);
    return;
  }
  const targetBlock = bot.findBlock({
    matching: blockId,
    maxDistance: 64
  });
  if (!targetBlock) {
    bot.chat(`No ${blockName} found nearby.`);
    return;
  }
  try {
    await bot.collectBlock.collect(targetBlock);  // auto-selects tool (mineflayer-tool) and pathfinds to block5
    bot.chat(`Collected a ${blockName}.`);
  } catch(err) {
    bot.chat(`Error collecting ${blockName}: ${err.message}`);
  }
}

// Helper: craft item if possible
async function craftItem(itemName) {
  const mcData = minecraftData(bot.version);
  // Check items and blocks data
  const itemData = mcData.itemsByName[itemName] || mcData.blocksByName[itemName];
  if (!itemData) {
    bot.chat(`Unknown item: ${itemName}`);
    return;
  }
  const itemId = itemData.id;
  // Check existing inventory
  if (bot.inventory.count(itemId, null) > 0) {
    bot.chat(`I already have some ${itemName}.`);
    return;
  }
  // Find a crafting recipe
  const recipes = bot.recipesFor(itemId, null, 1);
  if (!recipes || recipes.length === 0) {
    bot.chat(`No recipe found for ${itemName}.`);
    return;
  }
  const recipe = recipes[0];
  // Find a nearby crafting table if needed (for 3x3 recipes)
  const tableBlock = bot.findBlock({
    matching: minecraftData(bot.version).blocksByName.crafting_table.id,
    maxDistance: 32
  });
  try {
    await bot.craft(recipe, 1, tableBlock || null);
    bot.chat(`Crafted 1 ${itemName}.`);
  } catch(err) {
    bot.chat(`Failed to craft ${itemName}: ${err.message}`);
  }
}

// Track last health to detect damage, and count attacks
let lastHealth = bot.health;
let attackCount = 0;
bot.on('health', () => {
  // If health decreased, bot was hurt
  if (bot.health < lastHealth) {
    attackCount++;
    // Find nearest mob (excluding creepers) to assume as attacker
    const possibleAttackers = Object.values(bot.entities).filter(e => 
      e && e.type === 'mob' && e.mobType && e.mobType.toLowerCase() !== 'creeper'
    );
    if (possibleAttackers.length > 0) {
      const attacker = possibleAttackers[0];
      bot.chat(`Ouch, a ${attacker.displayName} hurt me!`);  // using entity.displayName6
      if (attackCount >= 3) {
        bot.chat(`I'll get you, ${attacker.displayName}!`);
        bot.pvp.attack(attacker);
        attackCount = 0;
      }
    }
  }
  lastHealth = bot.health;
});

// Respond to creeper spawns (avoid them and announce)
bot.on('entitySpawn', entity => {
  if (entity.type === 'mob' && entity.mobType && entity.mobType.toLowerCase() === 'creeper') {
    // Count creepers in vicinity
    const creeperCount = Object.values(bot.entities).filter(e => 
      e && e.type === 'mob' && e.mobType && e.mobType.toLowerCase() === 'creeper'
    ).length;
    if (creeperCount > 1) bot.chat('Ahhh creepers!');
    else bot.chat('Ahhh creeper!');
    // Flee: set goal to move away from creeper
    const pos = bot.entity.position;
    const fleePos = pos.offset((Math.random()-0.5)*20, 0, (Math.random()-0.5)*20);
    bot.pathfinder.setGoal(new GoalBlock(Math.floor(fleePos.x), Math.floor(fleePos.y), Math.floor(fleePos.z)));
  }
});

// Handle chat commands
bot.on('chat', (username, message) => {
  if (username === bot.username) return;
  const msg = message.toLowerCase();
  if (msg === 'disconnect') {
    bot.chat('Disconnecting...');
    bot.quit();
  } else if (msg.startsWith('mine ')) {
    const blockName = msg.split(' ')[1];
    mineBlockType(blockName);
  } else if (msg.startsWith('craft ')) {
    const itemName = msg.split(' ')[1];
    craftItem(itemName);
  }
});
